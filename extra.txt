    // for (int i = 0; i < xn->rows; i++)
    // {
    //     for (int j = 0; j < xn->cols; j++)
    //     {
    //         xn->data[i][j] = -(R->data[i][pivots + j]);
    //     }
    // }
    // for (int i = 0; i < maxPivots - pivots; i++)
    // {
    //     for (int j = 0; j < maxPivots - pivots; j++)
    //     {
    //         if (i == j)
    //         {
    //             xn->data[R->cols - (maxPivots - pivots) - i][i] = 1;
    //         }
    //         else
    //         {
    //             xn->data[R->cols - (maxPivots - pivots) - i][i] = 0;
    //         }
    //     }
    // }
// Matrix *rref(Matrix *m)
// {
//     //Creating a copy of m. We'll modify it to generate rref form
//     Matrix *e = newMatrix(m->rows, m->cols);
//     copyMatrix(e, m);
//     // int maxPivots = min(e->rows, e->cols);
//     int pivotRow = 0;
//     int pivotCol = 0;
//     //Converting to upper triangular
//     // for (int i = 0; i < maxPivots; i++)
//     while (pivotRow < e->rows && pivotCol < e->cols)
//     {
//         int switchRow = -1;
//         // _Bool isZero = false;
//         if (!e->data[pivotRow][pivotCol])
//         {
// // isZero = true;
// #ifdef UD
//             printf("Zero at: %d %d\n", pivotRow, pivotCol);
// #endif
//             for (int j = pivotRow + 1; j < e->rows; j++)
//             {
//                 if (e->data[j][pivotCol])
//                 {
//                     switchRow = j;
// #ifdef UD
//                     printf("Switch %d %d\n", pivotRow, j);
// #endif
//                     switchRows(e, pivotRow, switchRow);
//                     // printMatrix(e);
//                     break;
//                 }
//             }
//             if (switchRow == -1)
//             {
// #ifdef UD
//                 printf("No switch for row: %d\n", pivotRow);
// #endif
//                 pivotCol++;
//                 continue;
//             }
//         }
//         // if (isZero && switchRow == -1)
//         // {
//         //     continue;
//         // }
//         for (int j = pivotRow + 1; j < e->rows; j++)
//         {
//             if (e->data[j][pivotCol])
//             {
//                 double r = e->data[j][pivotCol] / e->data[pivotRow][pivotCol];
// // printf("\n");
// #ifdef UD
//                 printf("%d %d %d %lf %lf r : %lf\n\n", pivotRow, pivotCol, j, e->data[j][pivotCol], e->data[pivotRow][pivotCol], r);
// #endif
//                 for (int k = pivotCol; k < e->cols; k++)
//                 {
//                     e->data[j][k] -= r * e->data[pivotRow][k];
//                 }
//             }
// #ifdef UD
//             printMatrix(e);
//             printf("\n");
// #endif
//         }
//         pivotRow++;
//         pivotCol++;
//         // printMatrix(m);
//     }
// #ifdef UD
//     printMatrix(e);
//     printf("\nUpper triangular done!\n\n");
// #endif

//     //Converting to rref from upper triangular
//     //Select a pivot
// #ifdef R
//     pivotRow = 0;
//     pivotCol = 0;
//     // for (int i = 0; i < maxPivots; i++)
//     while (pivotRow < e->rows && pivotCol < e->cols)
//     {
//         if (!e->data[pivotRow][pivotCol])
//         {
//             pivotCol++;
//             continue;
//         }
//         else
//         {
//             for (int j = pivotRow - 1; j >= 0; j--)
//             {
//                 double r = e->data[j][pivotCol] / e->data[pivotRow][pivotCol];
// #ifdef RD
//                 printMatrix(e);
//                 printf("\n");
//                 printf("%d %d %d %lf %lf r : %lf\n\n", pivotRow, pivotCol, j, e->data[j][pivotCol], e->data[pivotRow][pivotCol], r);
//                 // printf("%d %d %lf %lf r : %lf\n", , j, e->data[j][i], e->data[i][i], r);
// #endif
//                 //Row operations
//                 for (int k = pivotCol; k < e->cols; k++)
//                 {
//                     // printf("%ld %ld %ld", i, j, k);
//                     // if (e->data[j][k] != 0)
//                     // {
//                     e->data[j][k] -= r * e->data[pivotRow][k];
//                     // }
//                 }
//             }
//         }
//         pivotRow++;
//         pivotCol++;
//         // printMatrix(e);
//     }
//     //Make all pivot elements '1'
//     pivotRow = 0;
//     pivotCol = 0;
//     while (pivotRow < e->rows && pivotCol < e->cols)
//     {
//         if (!e->data[pivotRow][pivotCol])
//         {
//             pivotCol++;
//             continue;
//         }
//         int quotient = e->data[pivotRow][pivotCol];
//         for (int j = 0; j < e->cols; j++)
//         {
//             if (e->data[pivotRow][j])
//                 e->data[pivotRow][j] /= quotient;
//         }
//         pivotRow++;
//         pivotCol++;
//     }
// #endif
//     return e;
// }

// Matrix *gaussUpperTriangular(Matrix *m)
// {
//     Matrix *u = newMatrix(m->rows, m->cols);
//     copyMatrix(u, m);
//     // memcpy(u, m, sizeof(m));
//     printMatrix(u);
//     for (int i = 0; i < u->rows; i++)
//     {
//         for (int k = i + 1; k < u->rows; k++)
//         {
//             double r = u->data[k][i] / u->data[i][i];
//             for (int j = 0; j < u->cols; j++)
//             {
//                 u->data[k][j] -= r * u->data[i][j];
//             }
//         }
//     }
//     return u;
// }

// Matrix *backSubstitution(Matrix *u)
// {
//     printf("inside");
//     Matrix *v = newMatrix(u->rows, 1);
//     for (int i = 0; i < v->rows; i++)
//     {
//         v->data[i][0] = 0;
//     }
//     printf("Hey");
//     for (int i = u->rows - 1; i >= 0; i--)
//     {
//         printf("Hey");
//         double ans = u->data[i][u->cols - 1];
//         printf("Hey");
//         for (int j = i + 1; j < u->cols - 1; j++)
//         {
//             ans -= v->data[j][0] * u->data[i][j];
//         }
//         ans /= u->data[i][i];
//         v->data[i][0] = ans;
//     }
//     printf("\n%d\n", v->rows);
//     printMatrix(v);
//     return v;
// }

// Matrix *m1 = newMatrix(3, 3);
// Matrix *m2 = newMatrix(3, 3);
// int data[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
// for (int i = 0; i < 3; i++)
// {
//     memcpy(m1->data[i], data[i], sizeof(double) * 3);
//     memcpy(m2->data[i], data[i], sizeof(double) * 3);
// }
// for (int i = 0; i < 3; i++)
// {
//     for (int j = 0; j < 3; j++)
//     {
//         m1->data[i][j] = data[i][j];
//         m2->data[i][j] = data[i][j];
//     }
// }
// Matrix *m2 = gaussUpperTriangular(m1);
// printf("Outside\n");
// Matrix *v = backSubstitution(m2);
// printf("\n%d\n", v->rows);
// printMatrix(v);
// free(v);
// readMatrix(m2);
// Matrix *m = addMatrix(m1, m2, true);
// for (int i = 0; i < 3; i++)
// {
//     for (int j = 0; j < 3; j++)
//     {
//         // m1->data[i][j] = data[i][j];
//         printf("%lf ", m->data[i][j]);
//     }
//     printf("\n");
// }

// typedef struct Matrix Matrix;

// typedef struct Matrix Matrix;
// #define Matrix *struct Matrix *;

// matrix *addMatrix(matrix *m1, matrix *m2, _Bool opcode)
// {
//     if (m1->rows != m2->rows || m1->cols != m2->cols)
//     {
//         return NULL;
//     }
//     matrix *matrix = newMatrix(m1->rows, m1->cols);
//     for (int i = 0; i < m1->rows; i++)
//     {
//         for (int j = 0; j < m1->cols; j++)
//         {
//             if (opcode)
//                 matrix->data[i][j] = m1->data[i][j] + m2->data[i][j];
//             else
//                 matrix->data[i][j] = m1->data[i][j] - m2->data[i][j];
//         }
//     }
//     return matrix;
// }

void copyMatrix(matrix *d, matrix *s)
{
    int i, j;
    for (i = 0; i < s->rows; i++)
    {
        for (j = 0; j < s->cols; j++)
        {
            d->data[i][j] = s->data[i][j];
        }
    }
}
